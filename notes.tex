\documentclass[a4paper]{article}

% In case we need to use TeXisms in the title before Hyperef is loaded
\def\texorpdfstring#1#2{#2}

\usepackage{hyperref}

\newcommand{\theTitle}{Introduction to Functional
  Programming\texorpdfstring{\thanks{By Tony Morris, Nicta}}{ (By Tony Morris,
  Nicta)} --- Workshop Notes}
\newcommand{\theAuthor}{Olivier Mehani}

\hypersetup{pdfstartview=FitV,
  colorlinks=true, linkcolor=black, citecolor=black, urlcolor=blue,
  pdftitle={\theTitle}, pdfauthor={\theAuthor}%, pdfkeywords={\theKeywords}
}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[australian]{babel}

\usepackage{url}
\DeclareUrlCommand\fspath{\urlstyle{tt}}

\newcommand{\latinlocution}[1]{\textit{#1}}
\newcommand{\eg}{\latinlocution{e.g.}}
\newcommand{\ie}{\latinlocution{i.e.}}
%\newcommand{\etc}{\latinlocution{etc.}}
%\newcommand{\apriori}{\latinlocution{a priori}}
%\newcommand{\aposteriori}{\latinlocution{a posteriori}}
%\newcommand{\adhoc}{\latinlocution{ad hoc}}
%\newcommand{\etal}{\latinlocution{et al.}}
%\newcommand{\perse}{\latinlocution{per se}}
%\newcommand{\viz}{\latinlocution{viz.}}

%\newcommand{\mat}[1]{\boldsymbol{#1}}

\title{\theTitle}
\author{\theAuthor\thanks{The errors therein are only mine!}}
\date{23--24 January 20133}

\begin{document}

\maketitle

\section{Functional Programming}

Programming with functions. Functions produce values only given their arguments,
and nothing else (\eg, no for loops nor variable updates).

\section{Haskell}

Examples can be seen in \fspath{src/L01/Optional.hs}.

\begin{itemize}
  \item Algebraic data types (ADT) are declared with\\
    \verb_data Typename t = <constructor> | <constuctor> ... deriving (...)_
  \item Funcions prototypes \\
    \verb_funcName :: argA -> argB ... -> return_ where \verb_::_ can be read as
    ``is of type''
  \item Functions are then defined by what they return depending on their
    arguments
    \verb_funcName anyThing = returnValue_
  \item Funcion declaration (\verb_->_) is right-associative, they are declared dealing with \emph{types}

  \item All functions actually take only one argument, they however can return
    functions applied to followup arguments they are defined with
    \emph{variables}
  \item Function application is left-associative
  \item Pattern matching happens on constructors and datatypes
  \item \verb#_# matches variables we don't need
  \item Functions are prefixed by default, unless used as infix between
    backticks
  \item Functions starting with non-alpha characters should be declared in
    paretheses and can be used as infix without the parentheses
\end{itemize}

\begin{itemize}
  \item \verb_:t_ can be used to get the type of functions.
  \item \verb_:i_ can be used to get slightly more information on functions.
  \item \verb_:r_ reloads the environment defined in \fspath{.ghci}
\end{itemize}

\section{Cons Lists}

Examples can be seen in \fspath{src/L02/Lists.hs}.

A list is made by concatenating a single element, to a possibly \verb_Nil_ tail
list, through the Cons (\verb_:|_, here) operator.

\verb_foldLeft_ repetitively applies the its first argument (a function, maybe
lambda), to the head and rest of a list, returning its second argument in case
the list is Nil. Lambda functions are declared as
%
\verb_(\ arg1 arg2 ... -> anything with args)_:
%
``Given \verb_arg1_, \verb_arg2_, return \verb_anything with args_'' (\verb_\_
is the $\lambda$) \verb_foldRight_ replaces \verb_cons_ with its first argument,
and \verb_Nil_ with its second. The latter can work on infinite lists, while the
former needs to find a \verb_Nil_, as it loops until it finds it, and build the
return value from there.

\verb_._ is function composition: \verb_(.) f g -> \x f (g x)_

Conditional constructs are of the form \verb_if <test> then <a> else <b>_, which
is the equivalent to C \verb_<test>?<a>:<b>_.

Temporary definitions can be written within the scope of an expression using
\verb_let_:
%
\verb_fiilter f (h :| t) = if f h then (h :| fiilter f t) else fiilter f t_ and
%
\verb_fiilter f (h :| t) = let bli = fiilter f t in if f h then (h :| bli) else bli_
are the same.

\verb_flip_ allows to flip the expected arguments of a function. This can be
done, along with other code refactoring to, \eg, avoid duplication, as there is
no side effect to any of the functions used.


\section{Functors}

Examples can be seen in \fspath{src/L03/Functor.hs}.

Functors are abstract methods. They are declared as \verb_class_es and defined
with \verb_instance_s for specific types.

They can be likened to templates,\footnote{Matt, at QRL, did end up writing
functional code in C++.} but need to be specifically implemented for each type
they support.

\section{Monads}

Examples can be seen in \fspath{src/L03/Moonad.hs}.

Monads are abstract functors. They rely on low-level interfaces (\verb_>>=_, or
``bind'', and \verb_return_) for specific types to apply their higher level
functions. ``Bind'' extracts the information from the data, while ``Return''
re-formats an output into the specific type.

Binds, \verb_>>=,_ are useful to apply follow-up (potentially $\lambda$)
functions on the contents of Monads and The ``anonymous bind,'' \verb_>>_,
ignores that content, and is used when only the (side-)effect is desired (and
can be used to chain functions).

\section{Useful Basic Functions}

\begin{description}
  \item[\texttt{fmap}] run a functor on data inside a compound type
  \item[bind] (\verb_>>=_) run a functor on data inside a compound type
  \item[\texttt{apply}] apply a function repetitively to a list
  \item[\texttt{sequence}] unwrap a Monad out of a list
\end{description}

\section{More Haskell}

Haskell provides support for \verb_do_ notation, which makes it easier to write
some structures with binds. It allows to ignore anonymous binds, and provides a
more imperative-looking program. Consider \verb_convertInteractive_ from
\fspath{src/L03/Interactive.hs} (\verb_--_ introduces a comment):
\begin{verbatim}
convertInteractive ::
  IO ()
convertInteractive =
  putStr "Enter a string to convert to uppercase: " >>
  getLine >>= (\s -> -- IO [Char] >>= [Char]
  putStrLn (map toUpper s))
\end{verbatim}
This is competely equivalent to the \verb_do_-notation'ed
\begin{verbatim}
convertInteractive ::
  IO ()
convertInteractive =
   do putStr "Enter a string to convert to uppercase: "
      line <- getline
      putStrLn (map toUpper s))
\end{verbatim}

Another (interactive) example ($q(x)=(10+x)+(20\cdot x),\quad q(88)=1858$):
\begin{verbatim}
>> let q = do a <- (10+); b <- (20*); return (a+b)
>> q 88
1858
\end{verbatim}

\section{Monad Transformers}

Monad Transformers put two Monads together to create a new Monad (see
\fspath{MT.hs}). They wrap a specific inner Monad into any arbitrary outer one.

\end{document}
